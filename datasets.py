"""
synthetic 2D dataset generation for diffusion models.

This module defines a ``Synthetic2DDataset`` class that can generate a number
of simple two–dimensional distributions used in diffusion model demos.  Rather
than maintaining dozens of nearly identical dataset classes, this class
provides a uniform interface that dispatches to specific generation routines
based on a string identifier.  The generated data is always normalised to
the range ``[-1, 1]`` along each dimension.

Supported dataset names
-----------------------

``eight_gaussians``
    Eight isotropic Gaussian components arranged around a circle.  This
    distribution is commonly used to test how well a generative model can
    represent a multi‑modal density.

``moons``
    Two interleaving half circles as produced by ``sklearn.datasets.make_moons``.

``swiss_roll``
    A two‑dimensional projection of the three‑dimensional Swiss roll
    manifold generated by ``sklearn.datasets.make_swiss_roll``.

``banana``
    A simple curved “banana” shaped density.  This implementation samples
    points along an exponential spiral with additive noise to create a
    central cluster and a curved tail.  It serves as an example of a
    non‑linear unimodal distribution.

``central_banana``
    Similar to the ``banana`` distribution but with a much denser central
    cluster.  In addition to the curved tail it includes an extra blob of
    points sampled from a small Gaussian around the origin.

``moon_circles``
    A single crescent from the two‑moon dataset augmented with two small
    circular clusters.  It tests how well a model can handle a mixture of
    manifold and clustered structure.

``banana_circles``
    A banana‑shaped distribution with two noisy circular clusters and local
    scatter along the curve.  This dataset combines a non‑linear tail with
    small dense regions.

``moon_scatter``
    A single crescent with scattered points around it.  Points are jittered
    away from the crescent by Gaussian noise to create a diffuse band.

Example
-------

>>> ds = Synthetic2DDataset(name='eight_gaussians', num_samples=10000)
>>> X = ds.generate()
>>> X.min(axis=0), X.max(axis=0)
([-1., -1.], [1., 1.])

"""

from __future__ import annotations

import numpy as np
from sklearn.datasets import make_moons, make_swiss_roll


class Synthetic2DDataset:
    """Generate synthetic 2D datasets with a unified interface.

    Parameters
    ----------
    name : str
        Name of the dataset to generate.  Must be one of the supported
        identifiers listed in the module docstring.
    num_samples : int, optional
        Number of points to generate.  Default is ``10000``.
    noise_level : float, optional
        Noise parameter used by some distributions such as ``moons`` and
        ``swiss_roll``.  Default is ``0.1``.
    random_state : int, optional
        Seed for the underlying random number generator.  Default is ``42``.
    """

    def __init__(self, name: str, num_samples: int = 10_000, noise_level: float = 0.1,
                 random_state: int = 42) -> None:
        self.name = name.lower()
        self.num_samples = int(num_samples)
        self.noise_level = float(noise_level)
        self.random_state = int(random_state)
        # create a dedicated NumPy random generator for reproducibility
        self.rng = np.random.default_rng(self.random_state)

    def normalize(self, X: np.ndarray) -> np.ndarray:
        """Normalise a 2D array to the range ``[-1, 1]`` along each axis.

        Parameters
        ----------
        X : ndarray of shape (n_samples, 2)
            Input array to normalise.

        Returns
        -------
        ndarray of shape (n_samples, 2)
            Normalised array.
        """
        min_val = X.min(axis=0, keepdims=True)
        max_val = X.max(axis=0, keepdims=True)
        # avoid division by zero when max_val == min_val
        scale = np.where(max_val > min_val, max_val - min_val, 1.0)
        X_norm = 2.0 * (X - min_val) / scale - 1.0
        return X_norm.astype(np.float32)

    def generate(self) -> np.ndarray:
        """Generate the requested dataset and return normalised samples.

        Returns
        -------
        ndarray of shape (``num_samples``, 2)
            Generated points scaled to ``[-1, 1]``.
        """
        if self.name == 'eight_gaussians':
            X = self._generate_eight_gaussians()
        elif self.name == 'moons':
            X = self._generate_moons()
        elif self.name == 'swiss_roll':
            X = self._generate_swiss_roll()
        elif self.name == 'banana':
            X = self._generate_banana()
        elif self.name == 'central_banana':
            X = self._generate_central_banana()
        elif self.name == 'moon_circles':
            X = self._generate_moon_circles()
        elif self.name == 'banana_circles':
            X = self._generate_banana_circles()
        elif self.name in ('moon_scatter', 'moon_scatterings'):
            X = self._generate_moon_scatter()
        else:
            raise ValueError(f"Unknown dataset '{self.name}'.")
        return self.normalize(X)

    # generation routines -------------------------------------------------
    def _generate_eight_gaussians(self) -> np.ndarray:
        """Eight isotropic Gaussians on a circle of radius 8.

        The means are positioned at the corners of a square and at the
        cardinal points.  Each component contributes an equal number of
        points.
        """
        n_points = self.num_samples // 8
        # eight means: four diagonals and four axis‑aligned
        radius = 8.0
        d = radius / np.sqrt(2.0)
        means = [
            ( d,  d), ( d, -d), (-d,  d), (-d, -d),
            (0.0, -radius), (0.0, radius), (radius, 0.0), (-radius, 0.0)
        ]
        covariance = np.eye(2, dtype=np.float64)  # identity covariance for all Gaussians
        X = np.zeros((len(means) * n_points, 2), dtype=np.float64)
        for i, mean in enumerate(means):
            X[i * n_points:(i + 1) * n_points] = self.rng.multivariate_normal(mean, covariance, n_points)
        # handle remainder points if num_samples is not divisible by 8
        remainder = self.num_samples - len(means) * n_points
        if remainder > 0:
            X = np.vstack((X, self.rng.multivariate_normal(means[0], covariance, remainder)))
        return X

    def _generate_moons(self) -> np.ndarray:
        """Two interleaving half circles from sklearn with noise."""
        X, _ = make_moons(n_samples=self.num_samples, noise=self.noise_level,
                          random_state=self.random_state)
        return X.astype(np.float64)

    def _generate_swiss_roll(self) -> np.ndarray:
        """Swiss roll projected to 2D (x, z dimensions)."""
        X, _ = make_swiss_roll(n_samples=self.num_samples, noise=self.noise_level,
                               random_state=self.random_state)
        # take the x and z coordinates
        X = X[:, [0, 2]].astype(np.float64)
        return X

    def _generate_banana(self) -> np.ndarray:
        """A simple banana‑shaped distribution.

        Points are sampled along an exponential spiral with small random offsets
        to form a curved tail and a central cluster.  This is a simplified
        version of the more elaborate ``CentralBananaDataset`` defined in the
        original codebase.
        """
        # number of central cluster points
        central_points = max(1, self.num_samples // 20)
        tail_points = self.num_samples - central_points
        X = []
        # generate curved tail
        max_theta = 4.0 * np.pi
        for _ in range(tail_points):
            theta = self.rng.uniform(0.0, max_theta)
            r = np.exp(-0.25 * theta)
            x_center = r * np.cos(theta)
            y_center = r * np.sin(theta)
            # add small noise depending on distance from origin
            width = 0.05 + 0.1 * r
            x_offset = self.rng.uniform(-width, width)
            y_offset = self.rng.uniform(-width, width)
            X.append((x_center + x_offset, y_center + y_offset))
        # central cluster around origin
        cluster_sigma = 0.05
        X_center = self.rng.normal(loc=(0.0, 0.0), scale=cluster_sigma, size=(central_points, 2))
        X.extend(X_center)
        return np.array(X, dtype=np.float64)

    # ------------------------------------------------------------------
    # Additional synthetic datasets inspired by the original codebase

    def _generate_central_banana(self) -> np.ndarray:
        """Generate a banana distribution with a dense central cluster.

        This implementation closely follows the ``CentralBananaDataset`` defined
        in the original codebase.  It draws a spiral‐shaped set of tail points
        using an exponential distribution over angles and modulates the radial
        distance with a learnable shape function.  A fixed number of points are
        also sampled around the origin to form a dense central cluster.  If
        ``num_samples`` is less than the default central cluster size, the
        cluster size is reduced accordingly.

        Returns
        -------
        ndarray of shape (``num_samples``, 2)
            Points drawn from the central banana distribution.
        """
        # number of central points as defined in the reference implementation
        default_central = 500
        # ensure the number of central points does not exceed the total
        central_points = min(default_central, max(0, self.num_samples))
        # number of tail points fills the remainder
        tail_points = max(0, self.num_samples - central_points)

        # parameters for the banana shape
        sigma = 0.3
        max_distance = 1.0
        concentration_factor = 2.0
        decay = 0.6

        def banana_cen_pdf(theta: float) -> float:
            """Compute the radial distance for a given angle in the banana shape."""
            return max_distance * (np.exp(-decay * theta) * (1.0 + concentration_factor * np.sin(theta)))

        # generate tail points along the curved banana
        X_tail = []
        for _ in range(tail_points):
            # draw angle from an exponential distribution with scale parameter 0.25
            theta = self.rng.exponential(scale=0.25)
            r = banana_cen_pdf(theta)
            # width of the tail decreases with increasing radius
            width_effect = sigma * (1.0 - (r / (2.0 * max_distance)))
            x_center = r * np.cos(theta)
            y_center = r * np.sin(theta)
            # jitter within a square of side length ``width_effect``
            x_offset = self.rng.uniform(-width_effect / 2.0, width_effect / 2.0)
            y_offset = self.rng.uniform(-width_effect / 2.0, width_effect / 2.0)
            X_tail.append((x_center + x_offset, y_center + y_offset))
        X_tail = np.array(X_tail, dtype=np.float64) if len(X_tail) > 0 else np.empty((0, 2), dtype=np.float64)

        # generate central cluster points
        def generate_central_point() -> tuple:
            # angle around a fixed sector with Gaussian noise
            theta = np.pi / 3.0 + self.rng.normal(loc=0.0, scale=0.1)
            # radial distance drawn from a uniform distribution on [0.5, 0.8]
            r = max_distance * self.rng.uniform(0.5, 0.7)
            x_center = r * np.cos(theta)
            y_center = r * np.sin(theta)
            x_offset = self.rng.normal(loc=-0.5, scale=sigma / 4.0)
            y_offset = self.rng.normal(loc=-0.5, scale=sigma / 4.0)
            return (x_center + x_offset, y_center + y_offset)

        X_center = np.array([generate_central_point() for _ in range(central_points)], dtype=np.float64)

        # combine tail and central points
        X = np.vstack((X_tail, X_center)) if tail_points > 0 else X_center
        return X

    def _generate_moon_circles(self) -> np.ndarray:
        """Generate a half‑moon with two circular clusters on either side.

        This implementation reproduces the behaviour of ``MoonWithTwoCirclesUnboundedDataset``
        from the original codebase.  It constructs a crescent from the two‑moon dataset and
        augments it with two dense circular clusters.  The density of the circles is
        fixed up to a maximum of 500 points per cluster.  The total number of output
        points will equal ``num_samples``.

        Returns
        -------
        ndarray of shape (``num_samples``, 2)
            Combined crescent and circle points.
        """
        # fixed density of each circle as defined in the reference implementation
        default_density = 500
        # ensure the circle density does not exceed half of the sample size
        circle_density = min(default_density, max(0, self.num_samples // 3))
        # number of crescent points needed to achieve the desired total
        crescent_points = max(0, self.num_samples - 2 * circle_density)
        # generate enough points from make_moons to obtain the desired number of class‑0 samples
        # the original implementation calls make_moons(2*n_samples - 4*circle_density)
        total_moon_points = max(0, 2 * self.num_samples - 4 * circle_density)
        # ensure at least one sample is generated
        total_moon_points = max(total_moon_points, 2 * crescent_points)
        X_full, y_full = make_moons(n_samples=total_moon_points, noise=self.noise_level,
                                   random_state=self.random_state)
        # extract points belonging to the specified crescent class (0)
        crescent = X_full[y_full == 0]
        # truncate to the required number of crescent points
        if crescent.shape[0] >= crescent_points:
            crescent = crescent[:crescent_points]
        else:
            # if there are not enough points, pad by repeating
            repeats = (crescent_points + crescent.shape[0] - 1) // max(crescent.shape[0], 1)
            crescent = np.tile(crescent, (repeats, 1))[:crescent_points]
        crescent = crescent.astype(np.float64)

        # parameters for the two circles
        circle_radius = 0.2
        center1 = np.array([-1.5, -1.0], dtype=np.float64)
        center2 = np.array([1.5, -1.0], dtype=np.float64)
        # sample random angles and radii for circle points
        angles1 = 2.0 * np.pi * self.rng.random(circle_density)
        angles2 = 2.0 * np.pi * self.rng.random(circle_density)
        radii1 = circle_radius * np.sqrt(self.rng.random(circle_density)) + 0.05 * self.rng.standard_normal(circle_density)
        radii2 = circle_radius * np.sqrt(self.rng.random(circle_density)) + 0.05 * self.rng.standard_normal(circle_density)
        # convert polar coordinates to Cartesian coordinates
        circle1 = np.c_[radii1 * np.cos(angles1) + center1[0], radii1 * np.sin(angles1) + center1[1]]
        circle2 = np.c_[radii2 * np.cos(angles2) + center2[0], radii2 * np.sin(angles2) + center2[1]]
        X = np.vstack((crescent, circle1, circle2)) if crescent_points > 0 else np.vstack((circle1, circle2))
        return X.astype(np.float64)

    def _generate_banana_circles(self) -> np.ndarray:
        """Banana distribution with two circles and scattered points.

        Builds upon the basic banana shape by adding two small noisy circles
        and additional scatter along the banana curve.  This is inspired by
        the ``BananaWithTwoCirclesDataset`` from the original codebase.

        Returns
        -------
        ndarray of shape (``num_samples``, 2)
            Combined banana, circle and scatter points.
        """
        # allocate samples for circles and scatter (each 5 % of the total)
        circle_density = max(1, int(0.05 * self.num_samples))
        scatter_density = max(1, int(0.05 * self.num_samples))
        base_points = max(1, self.num_samples - 2 * circle_density - scatter_density)
        # generate base banana tail
        X_tail = []
        max_theta = 4.0 * np.pi
        for _ in range(base_points):
            theta = self.rng.uniform(0.0, max_theta)
            r = np.exp(-0.25 * theta)
            x_center = r * np.cos(theta)
            y_center = r * np.sin(theta)
            width = 0.05 + 0.1 * r
            x_offset = self.rng.uniform(-width, width)
            y_offset = self.rng.uniform(-width, width)
            X_tail.append((x_center + x_offset, y_center + y_offset))
        # two small circles near the tail
        circle_radius = 0.1
        center1 = np.array([-0.4, 0.5])
        center2 = np.array([0.5, -0.25])
        angles1 = 2.0 * np.pi * self.rng.random(circle_density)
        angles2 = 2.0 * np.pi * self.rng.random(circle_density)
        radii1 = circle_radius * np.sqrt(self.rng.random(circle_density)) + 0.05 * self.rng.standard_normal(circle_density)
        radii2 = circle_radius * np.sqrt(self.rng.random(circle_density)) + 0.05 * self.rng.standard_normal(circle_density)
        circle1 = np.c_[radii1 * np.cos(angles1) + center1[0], radii1 * np.sin(angles1) + center1[1]]
        circle2 = np.c_[radii2 * np.cos(angles2) + center2[0], radii2 * np.sin(angles2) + center2[1]]
        # scatter points along the banana curve
        X_scatter = []
        for _ in range(scatter_density):
            theta = self.rng.uniform(0.0, max_theta)
            r = np.exp(-0.25 * theta) * (1.0 + 0.1 * self.rng.standard_normal())
            x_noisy = r * np.cos(theta)
            y_noisy = r * np.sin(theta)
            X_scatter.append((x_noisy, y_noisy))
        X_scatter = np.array(X_scatter, dtype=np.float64)
        X = np.vstack([np.array(X_tail, dtype=np.float64), circle1, circle2, X_scatter])
        return X

    def _generate_moon_scatter(self) -> np.ndarray:
        """Generate a half‑moon with a band of scattered points.

        This version follows the ``MoonWithScatteringsDataset`` exactly.  It generates
        ``2*num_samples - 2*scatter_density`` points from the two‑moon dataset and
        selects the crescent corresponding to ``crescent_class``.  It then adds
        Gaussian noise to **every** crescent point, but keeps only the first
        ``scatter_density`` of these scattered points.  The combined set of
        crescent points and scatter points has exactly ``num_samples`` elements.

        The scatter density is capped at 500 or half the sample size (whichever is
        smaller) to ensure a valid number of moons can be generated.  Setting
        ``scatter_density`` larger than ``num_samples`` would result in an invalid
        number of samples for ``make_moons``.

        Returns
        -------
        ndarray of shape (``num_samples``, 2)
            Combined crescent and scatter points.
        """
        # maximum scatter points as defined in the original dataset implementation
        max_scatter = 500
        # ensure scatter_density does not exceed half the total samples
        scatter_density = min(max_scatter, self.num_samples // 2)
        # compute the total number of two‑moon samples required
        total_moon_points = max(2 * self.num_samples - 2 * scatter_density, 2)
        # generate two‑moon dataset
        X_full, y_full = make_moons(n_samples=total_moon_points, noise=0.1,
                                   random_state=self.random_state)
        # select the crescent corresponding to the specified class
        crescent = X_full[y_full == self._get_crescent_class()]  # may be longer than needed
        # the number of crescent points we need is the remainder after allocating scatter
        required_crescent = self.num_samples - scatter_density
        # truncate or pad the crescent to the exact number needed
        if crescent.shape[0] >= required_crescent:
            crescent = crescent[:required_crescent]
        else:
            repeats = (required_crescent + crescent.shape[0] - 1) // max(crescent.shape[0], 1)
            crescent = np.tile(crescent, (repeats, 1))[:required_crescent]
        crescent = crescent.astype(np.float64)
        # create scatter points by adding Gaussian noise to each crescent point
        scatter_band = 0.3
        if scatter_density > 0 and crescent.shape[0] > 0:
            # vectorised noise for all crescent points
            noise = scatter_band * self.rng.standard_normal((crescent.shape[0], 2))
            all_scatter_points = crescent + noise
            # keep only the first ``scatter_density`` points
            scatter_points = all_scatter_points[:scatter_density]
        else:
            scatter_points = np.empty((0, 2), dtype=np.float64)
        # combine crescent and scatter points
        X = np.vstack((crescent, scatter_points)) if required_crescent > 0 else scatter_points
        return X.astype(np.float64)

    def _get_crescent_class(self) -> int:
        """Return the class label used for crescent selection in moon datasets.

        A helper function used by ``_generate_moon_scatter`` to allow overriding
        the crescent class in the future.  Currently always returns ``0``.
        """
        return 0
